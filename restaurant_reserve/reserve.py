#!/usr/bin/env python3
""" 4 Charles Prime Rib ‚Äî Resy Reservation Sniper =============================================  Sleeps until the 9 AM ET daily drop then fires a burst of requests the moment new slots go live (reservations open exactly 21 days in advance).  Usage:     python reserve.py                          # snipe today's drop (dining date = today + 21 days)     python reserve.py --date 2026-03-15        # snipe the drop for a specific dining date     python reserve.py --notify-only            # alert only, don't auto-book     python reserve.py --party-size 4           # override party size     python reserve.py --times "19:00,19:30,20:00"  Quick start:     1. cp .env.example .env     2. Fill in RESY_EMAIL, RESY_PASSWORD, and at least NTFY_TOPIC     3. Install the ntfy app on your phone ‚Üí subscribe to your topic name     4. python reserve.py """ import argparse import logging import os import signal import sys import time from dataclasses import dataclass, field from datetime import date, datetime, timedelta, timezone from typing import List, Optional  try:     from zoneinfo import ZoneInfo     ET = ZoneInfo("America/New_York") except ImportError:     ET = timezone(timedelta(hours=-5))  # type: ignore[assignment]  from notifier import Notifier, NotifierConfig from resy_client import FOUR_CHARLES_VENUE_ID, ResyClient  logger = logging.getLogger(__name__)  RESERVATION_DROP_DAYS_AHEAD = 21 RESERVATION_DROP_HOUR_ET = 9 SNIPE_ATTEMPTS = 20 SNIPE_POLL_INTERVAL = 0.25   @dataclass class ReserveConfig:     resy_email: str = ""     resy_password: str = ""     resy_api_key: str = "VbWk7s3L4KiK5fzlO7JD3Q5EYolJI7n5"     venue_id: int = FOUR_CHARLES_VENUE_ID     party_size: int = 2     dining_date: str = ""     preferred_times: List[str] = field(default_factory=list)     auto_book: bool = True     discord_webhook_url: Optional[str] = None     ntfy_topic: Optional[str] = None     ntfy_server: str = "https://ntfy.sh"     email_to: Optional[str] = None     smtp_host: str = "smtp.gmail.com"     smtp_port: int = 587     smtp_user: Optional[str] = None     smtp_pass: Optional[str] = None     twilio_account_sid: Optional[str] = None     twilio_auth_token: Optional[str] = None     twilio_from: Optional[str] = None     twilio_to: Optional[str] = None   def load_config_from_env(env_path: str = ".env") -> ReserveConfig:     env_vars: dict = {}     if os.path.exists(env_path):         try:             from dotenv import dotenv_values             env_vars = dict(dotenv_values(env_path))         except ImportError:             with open(env_path) as f:                 for line in f:                     line = line.strip()                     if line and not line.startswith("#") and "=" in line:                         k, _, v = line.partition("=")                         env_vars[k.strip()] = v.strip().strip('"').strip("'")      def get(key: str, default: str = "") -> str:         return os.environ.get(key) or env_vars.get(key) or default      preferred_times_raw = get("PREFERRED_TIMES")      return ReserveConfig(         resy_email=get("RESY_EMAIL"),         resy_password=get("RESY_PASSWORD"),         resy_api_key=get("RESY_API_KEY", "VbWk7s3L4KiK5fzlO7JD3Q5EYolJI7n5"),         venue_id=int(get("VENUE_ID", str(FOUR_CHARLES_VENUE_ID))),         party_size=int(get("PARTY_SIZE", "2")),         dining_date=get("DINING_DATE"),         preferred_times=[t.strip() for t in preferred_times_raw.split(",") if t.strip()]         if preferred_times_raw else [],         auto_book=get("AUTO_BOOK", "true").lower() == "true",         discord_webhook_url=get("DISCORD_WEBHOOK_URL") or None,         ntfy_topic=get("NTFY_TOPIC") or None,         ntfy_server=get("NTFY_SERVER", "https://ntfy.sh"),         email_to=get("EMAIL_TO") or None,         smtp_host=get("SMTP_HOST", "smtp.gmail.com"),         smtp_port=int(get("SMTP_PORT", "587")),         smtp_user=get("SMTP_USER") or None,         smtp_pass=get("SMTP_PASS") or None,         twilio_account_sid=get("TWILIO_ACCOUNT_SID") or None,         twilio_auth_token=get("TWILIO_AUTH_TOKEN") or None,         twilio_from=get("TWILIO_FROM") or None,         twilio_to=get("TWILIO_TO") or None,     )   def get_drop_datetime(dining_date_str: str) -> datetime:     dining_date = datetime.strptime(dining_date_str, "%Y-%m-%d").date()     drop_date = dining_date - timedelta(days=RESERVATION_DROP_DAYS_AHEAD)     return datetime(drop_date.year, drop_date.month, drop_date.day,                     RESERVATION_DROP_HOUR_ET, 0, 0, tzinfo=ET)   def sleep_until(target: datetime) -> None:     now = datetime.now(tz=ET)     delta = (target - now).total_seconds()     if delta <= 0:         return      logger.info("Waiting until drop at %s ET ...", target.strftime("%Y-%m-%d %H:%M:%S"))      while True:         now = datetime.now(tz=ET)         remaining = (target - now).total_seconds()         if remaining <= 0:             break         if remaining > 3600:             logger.info("  %.1f hours remaining ...", remaining / 3600)             time.sleep(min(remaining - 60, 3600))         elif remaining > 60:             logger.info("  %.0f minutes remaining ...", remaining / 60)             time.sleep(min(remaining - 5, 60))         else:             logger.info("  %.1f seconds remaining ‚Äî standing by ...", remaining)             time.sleep(max(remaining - 0.1, 0))             break   def slot_matches_times(slot: dict, preferred_times: List[str]) -> bool:     if not preferred_times:         return True     start = slot.get("date", {}).get("start", "")     return any(t in start for t in preferred_times)   def format_slot_list(slots: list, max_show: int = 8) -> str:     lines = []     for s in slots[:max_show]:         start = s.get("date", {}).get("start", "unknown")         stype = s.get("config", {}).get("type", "")         lines.append(f"  {start}  [{stype}]")     if len(slots) > max_show:         lines.append(f"  ... and {len(slots) - max_show} more")     return "\n".join(lines)   def run(cfg: ReserveConfig) -> None:     resy = ResyClient(         email=cfg.resy_email,         password=cfg.resy_password,         api_key=cfg.resy_api_key,         payment_method_id=int(os.environ.get("RESY_PAYMENT_ID", "") or 0) or None,     )     notifier = Notifier(         NotifierConfig(             discord_webhook_url=cfg.discord_webhook_url,             ntfy_topic=cfg.ntfy_topic,             ntfy_server=cfg.ntfy_server,             email_to=cfg.email_to,             smtp_host=cfg.smtp_host,             smtp_port=cfg.smtp_port,             smtp_user=cfg.smtp_user,             smtp_pass=cfg.smtp_pass,             twilio_account_sid=cfg.twilio_account_sid,             twilio_auth_token=cfg.twilio_auth_token,             twilio_from=cfg.twilio_from,             twilio_to=cfg.twilio_to,         )     )      logger.info("Logging in to Resy as %s ...", cfg.resy_email)     if not resy.login():         notifier.alert(             "‚ùå Resy login failed ‚Äî sniper aborted",             "Could not authenticate with Resy.\n\n"             "Possible causes:\n"             "‚Ä¢ Wrong RESY_EMAIL or RESY_PASSWORD in GitHub Secrets\n"             "‚Ä¢ Resy API temporarily down or changed\n"             "‚Ä¢ Account requires email verification or is locked\n\n"             "Action: verify credentials at https://resy.com, then update the secret.",         )         return      if cfg.dining_date:         dining_date_str = cfg.dining_date     else:         dining_date_str = (date.today() + timedelta(days=RESERVATION_DROP_DAYS_AHEAD)).strftime("%Y-%m-%d")      drop_dt = get_drop_datetime(dining_date_str)      logger.info(         "Target dining date: %s | party=%d | auto_book=%s",         dining_date_str, cfg.party_size, cfg.auto_book,     )     logger.info("Slot drop time:     %s ET", drop_dt.strftime("%Y-%m-%d %H:%M:%S"))     if cfg.preferred_times:         logger.info("Preferred times:    %s", ", ".join(cfg.preferred_times))      sleep_until(drop_dt)      snipe_start = datetime.now(tz=ET)     lateness_s = (snipe_start - drop_dt).total_seconds()     if lateness_s > 10:         logger.warning(             "Started %.0f seconds AFTER drop time (GitHub Actions scheduler delay).", lateness_s         )         late_note = (             f"\n‚ö†Ô∏è GitHub Actions started **{lateness_s:.0f}s late** after the 9 AM drop "             f"‚Äî popular slots may have been taken by then."         )     else:         late_note = ""      logger.info("*** DROP TIME ‚Äî firing up to %d requests ***", SNIPE_ATTEMPTS)     for attempt in range(1, SNIPE_ATTEMPTS + 1):         slots = resy.find_slots(             party_size=cfg.party_size,             check_date=dining_date_str,             venue_id=cfg.venue_id,         )          if slots:             matching = [s for s in slots if slot_matches_times(s, cfg.preferred_times)]              if cfg.preferred_times and not matching:                 slot_summary = format_slot_list(slots)                 msg = (                     f"Slots ARE available for {dining_date_str} (party of {cfg.party_size}) "                     f"but none match your preferred times ({', '.join(cfg.preferred_times)}).\n\n"                     f"All available times:\n{slot_summary}\n\n"                     f"Book manually if any work:\n"                     f"https://resy.com/cities/new-york-ny/venues/4-charles-prime-rib"                 )                 logger.warning("Slots found but none match preferred times. Notifying.")                 notifier.alert(f"4 Charles ‚Äî no preferred times available {dining_date_str}", msg)                 return              target_slots = matching if matching else slots             slot_summary = format_slot_list(target_slots)             logger.info("SLOTS AVAILABLE on %s!\n%s", dining_date_str, slot_summary)              if cfg.auto_book:                 _attempt_booking(resy, notifier, cfg, dining_date_str, target_slots)             else:                 msg = (                     f"Reservation available at 4 Charles Prime Rib!\n\n"                     f"Date: {dining_date_str}\n"                     f"Party size: {cfg.party_size}\n\n"                     f"Available slots:\n{slot_summary}\n\n"                     f"Book at: https://resy.com/cities/new-york-ny/venues/4-charles-prime-rib"                 )                 notifier.alert(f"4 Charles available ‚Äî {dining_date_str}", msg)             return          logger.info("Attempt %d/%d: no slots yet ...", attempt, SNIPE_ATTEMPTS)         if attempt < SNIPE_ATTEMPTS:             time.sleep(SNIPE_POLL_INTERVAL)      logger.warning("No slots found after %d attempts at drop time.", SNIPE_ATTEMPTS)     notifier.alert(         "4 Charles drop ‚Äî no slots found",         f"Checked {SNIPE_ATTEMPTS}√ó over {SNIPE_ATTEMPTS * SNIPE_POLL_INTERVAL:.0f}s "         f"starting at {snipe_start.strftime('%H:%M:%S ET')} but no slots appeared "         f"for **{dining_date_str}** (party of {cfg.party_size}).\n\n"         f"Possible reasons:\n"         f"‚Ä¢ Date fully sold out in under 1 second at drop\n"         f"‚Ä¢ Restaurant didn't release slots for that date yet\n"         f"‚Ä¢ Resy API returned empty results (transient glitch)\n"         f"‚Ä¢ Party size {cfg.party_size} unavailable ‚Äî try size 2 or 1{late_note}\n\n"         f"Check manually: https://resy.com/cities/new-york-ny/venues/4-charles-prime-rib",     )   def _attempt_booking(     resy: ResyClient,     notifier: Notifier,     cfg: ReserveConfig,     dining_date_str: str,     slots: list, ) -> None:     best_slot = slots[0]     slot_time = best_slot.get("date", {}).get("start", "unknown time")     slot_type = best_slot.get("config", {}).get("type", "")      logger.info("Attempting to book: %s [%s] ...", slot_time, slot_type)      result = resy.book_slot(best_slot, cfg.party_size, dining_date_str)      if result and result.get("resy_token"):         resy_token = result.get("resy_token")         msg = (             f"RESERVATION BOOKED at 4 Charles Prime Rib!\n\n"             f"Date:       {dining_date_str}\n"             f"Time:       {slot_time}\n"             f"Party size: {cfg.party_size}\n"             f"Resy token: {resy_token}\n\n"             f"View your reservation: https://resy.com/reservations"         )         logger.info("SUCCESS! %s", msg)         notifier.alert("BOOKED: 4 Charles Prime Rib!", msg)         sys.exit(0)     else:         slot_summary = format_slot_list(slots)         msg = (             f"Slot found but booking failed (grabbed by someone else?).\n\n"             f"Date: {dining_date_str}\n"             f"Available when detected:\n{slot_summary}\n\n"             f"Try booking manually NOW:\n"             f"https://resy.com/cities/new-york-ny/venues/4-charles-prime-rib"         )         logger.warning("Booking failed for %s. Notifying user to book manually.", slot_time)         notifier.alert("4 Charles slot found ‚Äî book manually NOW!", msg)   def parse_args(argv=None) -> argparse.Namespace:     p = argparse.ArgumentParser(         description="Snipe a 4 Charles Prime Rib reservation on Resy at the 9 AM ET drop.",         formatter_class=argparse.RawDescriptionHelpFormatter,         epilog=__doc__,     )     p.add_argument("--env", default=".env", metavar="PATH",                    help="Path to .env config file (default: .env)")     p.add_argument("--notify-only", action="store_true",                    help="Alert when a slot is found but do not auto-book")     p.add_argument("--party-size", type=int, metavar="N",                    help="Party size (overrides PARTY_SIZE in .env)")     p.add_argument("--date", metavar="YYYY-MM-DD",                    help="Dining date to target (default: today + 21 days)")     p.add_argument("--times", metavar="HH:MM[,...]",                    help="Preferred start times e.g. '19:00,19:30,20:00'")     p.add_argument("--verbose", "-v", action="store_true",                    help="Enable DEBUG logging")     return p.parse_args(argv)   def main(argv=None) -> None:     args = parse_args(argv)      log_level = logging.DEBUG if args.verbose else logging.INFO     logging.basicConfig(         level=log_level,         format="%(asctime)s  %(levelname)-8s  %(message)s",         datefmt="%Y-%m-%d %H:%M:%S",     )      env_path = args.env     if not os.path.isabs(env_path):         env_path = os.path.join(os.path.dirname(__file__), env_path)      cfg = load_config_from_env(env_path)      if args.notify_only:         cfg.auto_book = False     if args.party_size:         cfg.party_size = args.party_size     if args.date:         cfg.dining_date = args.date     if args.times:         cfg.preferred_times = [t.strip() for t in args.times.split(",") if t.strip()]      if not cfg.resy_email or not cfg.resy_password:         logger.error("RESY_EMAIL and RESY_PASSWORD are required. Copy .env.example ‚Üí .env and fill them in.")         sys.exit(1)      def _handle_sigint(sig, frame):         logger.info("Interrupted. Exiting.")         sys.exit(0)     signal.signal(signal.SIGINT, _handle_sigint)      try:         run(cfg)     except KeyboardInterrupt:         logger.info("Interrupted.")         sys.exit(0)     except Exception:         import traceback         tb = traceback.format_exc()         logger.exception("Unexpected error ‚Äî sending crash report to Discord")         if cfg.discord_webhook_url:             try:                 import requests as _req                 _req.post(                     cfg.discord_webhook_url,                     json={"embeds": [{                         "title": "üí• Resy sniper crashed ‚Äî unexpected error",                         "description": f"This is a code/environment bug, not a sold-out situation.\n\n```\n{tb[:3800]}\n```",                         "color": 0xED4245,                     }]},                     timeout=10,                 )             except Exception:                 pass         sys.exit(1)   if __name__ == "__main__":     main()

""" Multi-channel notification system.  Supported channels:   - Discord    : Webhook — colored embeds, zero setup (recommended)   - ntfy.sh    : Free push notifications to your phone   - Email      : SMTP (works with Gmail app passwords, etc.)   - SMS/Twilio : Paid but reliable (~$0.01/message)  All configured channels are attempted on every alert. """ import logging import smtplib from dataclasses import dataclass, field from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from typing import Optional  import requests  logger = logging.getLogger(__name__)  _COLOR_GREEN  = 0x57F287 _COLOR_YELLOW = 0xFEE75C _COLOR_RED    = 0xED4245   @dataclass class NotifierConfig:     discord_webhook_url: Optional[str] = None     ntfy_topic: Optional[str] = None     ntfy_server: str = "https://ntfy.sh"     email_to: Optional[str] = None     smtp_host: str = "smtp.gmail.com"     smtp_port: int = 587     smtp_user: Optional[str] = None     smtp_pass: Optional[str] = None     twilio_account_sid: Optional[str] = None     twilio_auth_token: Optional[str] = None     twilio_from: Optional[str] = None     twilio_to: Optional[str] = None   class Notifier:     def __init__(self, config: NotifierConfig):         self.config = config         self._channels_configured = self._check_channels()      def _check_channels(self) -> list:         channels = []         if self.config.discord_webhook_url:             channels.append("discord")         if self.config.ntfy_topic:             channels.append("ntfy")         if self.config.email_to and self.config.smtp_user and self.config.smtp_pass:             channels.append("email")         if (             self.config.twilio_account_sid             and self.config.twilio_auth_token             and self.config.twilio_from             and self.config.twilio_to         ):             channels.append("sms")         if not channels:             logger.warning(                 "No notification channels configured! "                 "Set DISCORD_WEBHOOK_URL, NTFY_TOPIC, email credentials, or Twilio credentials in .env"             )         else:             logger.info("Notification channels: %s", ", ".join(channels))         return channels      def alert(self, title: str, body: str) -> bool:         """Send alert on all configured channels. Returns True if at least one succeeded."""         if not self._channels_configured:             print(f"\n*** ALERT: {title} ***\n{body}\n")             return False          success = False         if "discord" in self._channels_configured:             success = self._discord(title, body) or success         if "ntfy" in self._channels_configured:             success = self._ntfy(title, body) or success         if "email" in self._channels_configured:             success = self._email(title, body) or success         if "sms" in self._channels_configured:             success = self._sms(f"{title}\n{body}") or success         return success      def _discord(self, title: str, body: str) -> bool:         url = self.config.discord_webhook_url         t_lower = title.lower()         if "booked" in t_lower:             color = _COLOR_GREEN         elif "available" in t_lower or "found" in t_lower or "manually" in t_lower:             color = _COLOR_YELLOW         else:             color = _COLOR_RED          payload = {             "embeds": [{                 "title": title,                 "description": body[:4000],                 "color": color,             }]         }         try:             resp = requests.post(url, json=payload, timeout=10)             resp.raise_for_status()             logger.info("Discord alert sent")             return True         except Exception as e:             logger.error("Discord alert failed: %s", e)             return False      def _ntfy(self, title: str, body: str) -> bool:         cfg = self.config         url = f"{cfg.ntfy_server}/{cfg.ntfy_topic}"         try:             resp = requests.post(                 url,                 data=body.encode("utf-8"),                 headers={                     "Title": title,                     "Priority": "urgent",                     "Tags": "fork_and_knife,rotating_light,calendar",                 },                 timeout=10,             )             resp.raise_for_status()             logger.info("ntfy alert sent → topic: %s", cfg.ntfy_topic)             return True         except Exception as e:             logger.error("ntfy alert failed: %s", e)             return False      def _email(self, subject: str, body: str) -> bool:         cfg = self.config         msg = MIMEMultipart("alternative")         msg["From"] = cfg.smtp_user         msg["To"] = cfg.email_to         msg["Subject"] = subject         msg.attach(MIMEText(body, "plain"))          try:             with smtplib.SMTP(cfg.smtp_host, cfg.smtp_port, timeout=15) as server:                 server.ehlo()                 server.starttls()                 server.login(cfg.smtp_user, cfg.smtp_pass)                 server.sendmail(cfg.smtp_user, cfg.email_to, msg.as_string())             logger.info("Email alert sent → %s", cfg.email_to)             return True         except smtplib.SMTPAuthenticationError:             logger.error(                 "Email auth failed. For Gmail, use an App Password: "                 "https://myaccount.google.com/apppasswords"             )             return False         except Exception as e:             logger.error("Email alert failed: %s", e)             return False      def _sms(self, body: str) -> bool:         cfg = self.config         try:             from twilio.rest import Client         except ImportError:             logger.error("Twilio not installed. Run: pip install twilio")             return False         try:             client = Client(cfg.twilio_account_sid, cfg.twilio_auth_token)             client.messages.create(                 body=body[:1600],  # SMS limit                 from_=cfg.twilio_from,                 to=cfg.twilio_to,             )             logger.info("SMS alert sent → %s", cfg.twilio_to)             return True         except Exception as e:             logger.error("SMS alert failed: %s", e)             return False

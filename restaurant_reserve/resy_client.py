""" Resy API client (unofficial) for monitoring and booking reservations.  4 Charles Prime Rib venue ID on Resy: 834 Reservations drop 21 days in advance at 9 AM ET. """ import json import logging import time from typing import Optional  import requests  logger = logging.getLogger(__name__)  # Public Resy web-app API key (used by resy.com itself) DEFAULT_RESY_API_KEY = "VbWk7s3L4KiK5fzlO7JD3Q5EYolJI7n5" BASE_URL = "https://api.resy.com"  FOUR_CHARLES_VENUE_ID = 834   class ResyAuthError(Exception):     pass   class ResyClient:     """Thin wrapper around Resy's unofficial API."""      def __init__(         self,         email: str,         password: str,         api_key: str = DEFAULT_RESY_API_KEY,         payment_method_id: Optional[int] = None,     ):         self.email = email         self.password = password         self.api_key = api_key         self.auth_token: Optional[str] = None         self.payment_method_id: Optional[int] = payment_method_id      def _headers(self, include_auth: bool = True) -> dict:         headers = {             "Authorization": f'ResyAPI api_key="{self.api_key}"',             "Content-Type": "application/x-www-form-urlencoded",             "User-Agent": (                 "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "                 "AppleWebKit/537.36 (KHTML, like Gecko) "                 "Chrome/120.0.0.0 Safari/537.36"             ),             "Origin": "https://resy.com",             "Referer": "https://resy.com/",         }         if include_auth and self.auth_token:             headers["x-resy-auth-token"] = self.auth_token         return headers      def login(self) -> bool:         """Authenticate with Resy and store auth token + payment method ID."""         url = f"{BASE_URL}/3/auth/password"         payload = {"email": self.email, "password": self.password}         try:             resp = requests.post(                 url,                 data=payload,                 headers=self._headers(include_auth=False),                 timeout=10,             )             resp.raise_for_status()             data = resp.json()             self.auth_token = data.get("token")             payment = data.get("payment_method_default") or {}             self.payment_method_id = payment.get("id")             logger.info("Logged into Resy successfully.")             return True         except requests.HTTPError as e:             logger.error("Resy login failed (HTTP %s): %s", e.response.status_code, e.response.text)             return False         except Exception as e:             logger.error("Resy login error: %s", e)             return False      def find_slots(self, party_size: int, check_date: str, venue_id: int = FOUR_CHARLES_VENUE_ID) -> list:         """         Query available slots for a given date and party size.          Returns a list of slot dicts, each with .config.id and .date.start.         """         if not self.auth_token:             raise ResyAuthError("Not logged in. Call login() first.")          url = f"{BASE_URL}/4/find"         params = {             "lat": 0,             "long": 0,             "day": check_date,             "party_size": party_size,             "venue_id": venue_id,         }         try:             resp = requests.get(                 url,                 params=params,                 headers=self._headers(),                 timeout=10,             )             resp.raise_for_status()             data = resp.json()             venues = data.get("results", {}).get("venues", [])             if not venues:                 return []             return venues[0].get("slots", [])         except requests.HTTPError as e:             if e.response.status_code == 401:                 logger.warning("Auth token expired — re-logging in.")                 self.login()             else:                 logger.error("find_slots HTTP error %s: %s", e.response.status_code, e.response.text)             return []         except Exception as e:             logger.error("find_slots error: %s", e)             return []      def get_book_token(self, config_id: str, party_size: int, check_date: str) -> Optional[str]:         """         Exchange a slot config_id for a one-time booking token.          The token expires quickly — book immediately after calling this.         """         url = f"{BASE_URL}/3/details"         payload = {             "commit": 1,             "config_id": config_id,             "party_size": party_size,             "day": check_date,         }         try:             resp = requests.post(                 url,                 data=payload,                 headers=self._headers(),                 timeout=10,             )             resp.raise_for_status()             data = resp.json()             return data.get("book_token", {}).get("value")         except Exception as e:             logger.error("get_book_token error: %s", e)             return None      def book(self, book_token: str) -> Optional[dict]:         """         Complete the reservation using a book token.          Returns the booking confirmation dict on success, None on failure.         """         if not self.payment_method_id:             logger.error("No payment method on file. Resy requires a saved card to book.")             return None          url = f"{BASE_URL}/3/book"         payload = {             "book_token": book_token,             "struct_payment_method": json.dumps({"id": self.payment_method_id}),             "source_id": "resy.com-venue-details",         }         try:             resp = requests.post(                 url,                 data=payload,                 headers=self._headers(),                 timeout=10,             )             resp.raise_for_status()             return resp.json()         except requests.HTTPError as e:             logger.error("book() HTTP error %s: %s", e.response.status_code, e.response.text)             return None         except Exception as e:             logger.error("book() error: %s", e)             return None      def book_slot(self, slot: dict, party_size: int, check_date: str) -> Optional[dict]:         """Convenience: get book token then book in one call."""         config_id = slot.get("config", {}).get("id")         if not config_id:             logger.error("Slot has no config.id: %s", slot)             return None          book_token = self.get_book_token(config_id, party_size, check_date)         if not book_token:             return None          # Book token is short-lived — book immediately         return self.book(book_token)
